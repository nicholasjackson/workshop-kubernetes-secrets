# Defining secrets with the Vault Secrets Operator

Let's now see how we can use the Vault Secrets Operator to sync the secrets
we created in the previous section with Kubernetes.

To enable the syncing of secrets between Vault and Kubernetes we need to perform 
the folling tasks.

1. Create a Service Account that Vault will use to authenticate with Kubernetes.
2. Create a Vault role that maps the Service Account to a Vault policy.
3. Create a VaultAuth CRD that defines the authentication method to use.
4. Create a VaultSecret CRD that defines the secrets to sync with Kubernetes. 

Let's begin with creating the service account.

## Creating a Service Account for Vault Authentication

The Vault operator uses Kubernetes service account tokens to for authentication.
Before the operator requests the secrets from Vault it obtains the service account
token and uses this to authenticate with the Kubernetes authentication endpoint.

Vault then validates the token signature using the public key defined in the token
header. It then uses the token to make a call to the Kubernetes API to verify
that it is valid. Once these two steps have been completed, Vault extracts the
claims from the token and attempts to match them with the criteria in the role
that was specified during login. 

If all these steps pass, Vault returns a token to the Vault operator which has
the correct policy assigned to it. Policy in Vault allows a token to be used
to obtain secrets so the token that the operator gets back will alow it to access
the secrets that you define later the `VaultDynamicSecret` CRD.

First, add the service account to your Terraform code, you are using Terraform
to configure Kubernetes but many of the operations that you apply in this section 
are only Kubernetes CRDs and could also be applied using a YAML format.

```hcl
# create a service account for the app, this allows the vault operator to 
# authenticate the app to vault and retrieve the secrets
resource "kubernetes_service_account" "minecraft" {
  metadata {
    name = "minecraft"
  }
}
```

<Task id="add_service_account">
  Add the `kubernetes_service_account` to the file `database_secrets/k8s.tf`
</Task>

Next you need to create a secret that contains the service account token, 
recent changes to Kubernetes mean that the secret containing the token is not
automatically created. You can create this token by adding the following block
to your config.

```hcl
resource "kubernetes_secret" "minecraft-token" {
  metadata {
    name = "${kubernetes_service_account.minecraft.metadata.0.name}-token"
    annotations = {
      "kubernetes.io/service-account.name" = kubernetes_service_account.minecraft.metadata.0.name
    }
  }

  type = "kubernetes.io/service-account-token"
}
```

<Task id="add_service_account_secret">
  Add the `kubernetes_secret` to the file `database_secrets/k8s.tf`
</Task>

Next step is to define a cluster role binding for the service account
Vault uses this to access to the Kubernetes API and to determine the validity
of the token. By default service account tokens do not have this permission.

Add the following resource to your configuration.

```hcl
resource "kubernetes_cluster_role_binding" "minecraft" {
  metadata {
    name = "role-tokenreview-binding"
  }
  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = "system:auth-delegator"
  }
  subject {
    kind      = "ServiceAccount"
    name      = kubernetes_service_account.minecraft.metadata.0.name
    namespace = "default"
  }
}
```

<Task id="add_cluster_role">
  Add the `kubernetes_cluster_role_binding` to the file `database_secrets/k8s.tf`
</Task>

## Allowing access to secrets using policy

To control which secrets a service account has access to define policy allowing
certain permissions in Vault.

Permissions in Vault are path based, for example, the path to the secret that
can generate dynanmic database secrets with the reader role is:

```shell
database/minecraft/creds/reader
```

The permissions for these secrets are called `capabilities`, these define
the actions you can perform against the path.

Roughly translated the capabilities translate to HTTP methods, for example.

| Capability | HTTP Method |
| ---------- | ----------- |
| read       | GET         |
| create     | POST        |
| update     | PUT         |
| delete     | DELETE      |

When generating database credentials, the API operation that the
controller will call accepts a GET, POST, or PUT. For this reason, you can
create the following policy.

```hcl
resource "vault_policy" "minecraft_secrets" {
  name = "minecraft-secrets"

  policy = <<EOF
  path "${vault_database_secrets_mount.minecraft.path}/creds/reader" {

    capabilities = ["read", "create", "update"]
  }
  EOF
}
```

<Task id="add_policy">
  Add the `vault_policy` to the file `database_secrets/k8s.tf`
</Task>

## Configuring authentication using roles

Finally you need to add a authentication role for Vault that maps the policy 
you just created to the service account token. Vault can support authentication
to many different Kubernetes clsuters these are configured using a 
`kubernetes_auth_backend` that has been defined in a global cluster config.
The backend config contains the location of the Kubernetes API and the CA
that can be used to validate the TLS certificates presented by the cluster.

The role is the configuration that maps the particular service account to 
policy that provides access to secrets.

When the operator authenticates to Vault it does so by providing a token and
specifying the role that it would like to use for authentication. The role contains
the criteria that must be bet for before authentication is succesful. This criteria
is generally the service account name and namespace and optionally any metadata
that is encoded into the claims section of the service account token.

In this example you are going to only allow access if the service account token
has the name `minecraft` and it belongs to the kubernetes namespace `default`.

```hcl
resource "vault_kubernetes_auth_backend_role" "minecraft" {
  backend   = "kubernetes"
  role_name = "minecraft"

  bound_service_account_names      = [kubernetes_service_account.minecraft.metadata.0.name]
  bound_service_account_namespaces = ["default"]
  token_policies                   = [vault_policy.minecraft_secrets.name]
}
```

<Task id="add_role">
  Add the `vault_kubernetes_auth_backend_role` to the file `database_secrets/k8s.tf`
</Task>

Now that is all done let's add the final two resources to sync the secret.

## Syncing Vault Secrets To Kubernetes Secrets

The first thing we need to add is a `VaultAuth` custom resource definition
that configures the authentication details like the service account to use
and the role.

There is not a specific terraform resource for this operation, however you can
use the `kubernetes_manafest` that accepts any Kubernetes YAML expressed
as HCL.

Add the following resource to your configuration.

```hcl
resource "kubernetes_manifest" "vaultauth_dev_auth" {
  manifest = {
    "apiVersion" = "secrets.hashicorp.com/v1beta1"
    "kind"       = "VaultAuth"
    "metadata" = {
      "name"      = "dev-auth"
      "namespace" = "default"
    }
    "spec" = {
      "allowedNamespaces" = [
        "*",
      ]
      "kubernetes" = {
        "role"                   = vault_kubernetes_auth_backend_role.minecraft.role_name
        "serviceAccount"         = kubernetes_service_account.minecraft.metadata.0.name
        "tokenExpirationSeconds" = 600
      }
      "method"             = "kubernetes"
      "mount"              = "kubernetes"
      "vaultConnectionRef" = "default"
    }
  }
}
```

<Task id="add_vault_auth">
  Add the `kubernetes_manifest` to the file `database_secrets/k8s.tf`
</Task>

Finally you can configure which secrets are synced to Kubernetes secrets
you do this using `VaultDynamicSecret` and `VaultStaticSecret` CRDs.

The `VaultDynamicSecret` CRD allows you to specify the vault secret that 
you would like to use and the kubernetes secret where you would like
the secret synced to. Once the controller has this configuration it manages
the lifecycle of the secret for you, you do not need to worry about the lifecycle of the secret expiring. The operator will automatically renew the
secret before it expires. For static secrets the operator periodically checks for changes and again automatically refreshes the secret.  

The following configuration syncs the Vault secret `database/minecraft/creds/reader`, and syncs it to the Kubernetes secret `minecraft-db`. The
operator has two modes, it can either create a new secret or sync the data
to an existing secret. Since the application has already been deployed using
a secret configured with static credentials, the example will overwrite this
secret rather than creating a new one.

```hcl
resource "kubernetes_manifest" "vault_dynamic_secret" {
  manifest = {
    "apiVersion" = "secrets.hashicorp.com/v1beta1"
    "kind"       = "VaultDynamicSecret"
    "metadata" = {
      "name"      = "minecraft-db"
      "namespace" = "default"
    }
    "spec" = {
      "mount"     = vault_database_secrets_mount.minecraft.path
      "path"      = "creds/reader"

      "destination" = {
        "create" = true
        "name"   = "minecraft-db"
      }
      "vaultAuthRef" = "dev-auth"
    }
  }
}
```

<Task id="add_dynamic_secret">
  Add the `kubernetes_manifest` to the file `database_secrets/k8s.tf`
</Task>

Once you have added all the resources to the configuration, you can apply the configuration
using the following commands:

```shell
terraform apply
```

Next, let's validate that everything is working as correctly.